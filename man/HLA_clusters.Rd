% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Cluster_CB_by_count_in_allele_matrix.R
\name{HLA_clusters}
\alias{HLA_clusters}
\title{Getting raw scrHLAtag counts and analyzing distribution of HLA alleles per Cell Barcodes in UMAP space}
\usage{
HLA_clusters(
  reads,
  k = 2,
  seu = NULL,
  CB_rev_com = FALSE,
  geno_metadata_id = NULL,
  hla_with_counts_above = 0,
  CBs_with_counts_above = 25,
  match_CB_with_seu = TRUE,
  method = "consensus",
  n_PCs = 50,
  dbscan_minPts = 30,
  QC_mm2 = TRUE,
  s1_percent_pass_score = 80,
  AS_percent_pass_score = 80,
  NM_thresh = 15,
  de_thresh = 0.01,
  parallelize = FALSE,
  pt_size = 0.5,
  return_heavy = FALSE,
  seed = NULL,
  suppress_plots = FALSE,
  ...
)
}
\arguments{
\item{reads}{is the scrHLAtag count file including columns for CB, UMI, and HLA alleles (\url{https://github.com/furlan-lab/scrHLAtag}).}

\item{k}{can be \code{NULL} or a fixed number of cluster counts to partition the datapoints into, e.g. the number of entities or genotypes you \emph{think} there might be in your captured sample. If \code{NULL}, each clustering method will automatically determine \code{k} clusters on its own (will not work for \code{"hclust"} and \code{"kmeans"}, which need predefined \code{k}s).}

\item{seu}{is the Seurat object associated with the scrHLAtag count file (\url{https://satijalab.org/seurat/index.html}).}

\item{CB_rev_com}{logical, called \code{TRUE} if the need to obtain the reverse complement of Cell Barcodes (CBs) is desired; default is \code{FALSE}.}

\item{geno_metadata_id}{a character, the column ID of the Seurat metadata designated to distinguish genotypes, if this information is available. \code{NULL} by default or when genotyping information is not available.}

\item{hla_with_counts_above}{number of total reads accross CBs at or above which an HLA allele is retained in the matrix.}

\item{CBs_with_counts_above}{number of total reads accross HLA alleles at or above which a CB is retained in the matrix. Note: \code{stats::princomp()} can only be used with at least as many units (CBs) as variables (HLAs), thus the function will make sure that number of CBs is equal or more than available HLA alleles in the matrix.}

\item{match_CB_with_seu}{logical, called \code{TRUE} if filtering CBs in the scrHLAtag count file with matching ones in the Seurat object is desired.}

\item{method}{the name of the graph-based clustering method to be used for partitioning cells based on their HLA count patterns. The choice is between a Community structure detection method: \code{"leiden"}, a Density-based method: \code{"dbscan"}, a Connectivity-based method: \code{"hclust"}, a Centroid-based method: \code{"kmeans"}, or a Distribution-based method: \code{"gmm"} (for Gaussian Mixture Model). The methods are run with their respective Default parameters. Some of those methods may predict \emph{true} allogeneic entities with better accuracy than others; as we cannot know a priori which is the best method, we propose the method: \code{"consensus"}, which groups cells in the same cluster if they agree on membership in > 50 percent of methods, otherwise they are unclassified (\code{NA}s).}

\item{n_PCs}{the number of top principal components to retain in downstream clustering and umap analyses; default is \code{50} or the top 80 percent of PCs, whichever is smaller.}

\item{dbscan_minPts}{only works for the  \code{"dbscan"} method: number of minimum points required in the epsilon neighborhood radius (\code{eps}) of core points. While the other methods require 1 parameter (e.g., \code{k}), \code{"dbscan"} requires 2: \code{eps} and \code{minPts}. To acheive desired \code{k} clusters, a range of \code{eps} parameter is tested against a fixed \code{minPts}, which is provided here. Default at \code{30}, but can be adjusted higher or lower depending on how small and 'clumped' an allogeneic entity is suspected to be.}

\item{QC_mm2}{logical, called \code{TRUE} if removing low quality reads based on minimap2 tags is desired.}

\item{s1_percent_pass_score}{percentage, \code{0} to \code{100}, cuttoff from the maximum score (best quality) of the minimap2 's1' tag, which a read needs to acheive to pass as acceptable; default at \code{80} and becomes less inclusive if value increases.}

\item{AS_percent_pass_score}{percentage, \code{0} to \code{100}, cuttoff from the maximum score (best quality) of the minimap2 'AS' tag, which a read needs to acheive to pass as acceptable; default at \code{80} and becomes less inclusive if value increases.}

\item{NM_thresh}{the number of mismatches and gaps in the minimap2 alignment at or below which the quality of the read is acceptable; default is \code{15}.}

\item{de_thresh}{the gap-compressed per-base sequence divergence in the minimap2 alignment at or below which the quality of the read is acceptable; the number is between \code{0} and \code{1}, and default is \code{0.01}.}

\item{parallelize}{logical, called \code{TRUE} if using parallel processing (multi-threading) is desired; default is \code{FALSE}.}

\item{pt_size}{a number, the size of the geometric point displayed by ggplot2.}

\item{return_heavy}{logical, if \code{TRUE} it also returns the now processed scrHLAtag count file (minimap2 QCed, CB reverse comp'ed, etc..) which is usually a heavy object memory-wise; default is \code{FALSE}.}

\item{seed}{numeric (or \code{NULL}), to set seed (or not) in the environment for reproducibility}

\item{suppress_plots}{called \code{TRUE} to suppress plots from appearing while running the function.}

\item{...}{arguments passed onto \code{uwot::umap()}.}
}
\value{
a large list containing DataFrame with UMAP coordinates and ggplot of HLA clusters
}
\description{
Getting raw scrHLAtag counts and analyzing distribution of HLA alleles per Cell Barcodes in UMAP space
}
\examples{
samples <- c("AML_101_BM", "AML_101_34")
mol_info <- c("molecule_info_gene.txt.gz", "molecule_info_mRNA.txt.gz")
cts <- list()
for (i in 1:length(mol_info)){
  dl<-lapply(samples, function(sample){
    d<-read.table(file.path("path/to/scrHLAtag/out/files", sample,
                            mol_info[i]), header = F, sep=" ", fill = T) 
    d$V1<-paste0(sample, "_", d$V1, "-1")
    colnames(d)<-c("name","CB", "nb", "UMI", "gene", "query_len","start", "mapq", "cigar", "NM", "AS", "s1", "de", "seq")
    d$samp <- sample
    d
  })
  ctsu<-do.call(rbind,dl)
  rm(dl)
  cts[[str_sub(strsplit(mol_info[i], "\\\\.")[[1]][1], start= -4)]] <- ctsu
  rm(ctsu)
}
HLA_umap <- HLA_clusters(reads = cts[["mRNA"]], k = 2, seu = your_Seurat_Obj, geno_metadata_id = "geno", hla_with_counts_above = 5, CBs_with_counts_above = 35)
}
