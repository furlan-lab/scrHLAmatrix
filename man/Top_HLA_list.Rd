% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Determine_HLA_genotypes.R
\name{Top_HLA_list}
\alias{Top_HLA_list}
\title{A comprehensive function to extract the top HLA alleles from the scrHLAtag count files (based on the most counts per Cell Barcode)}
\usage{
Top_HLA_list(
  reads_1,
  reads_2 = NULL,
  allogeneic_entities = 2,
  seu = NULL,
  CB_rev_com = FALSE,
  hla_with_counts_above = 0,
  CBs_with_counts_above = 50,
  match_CB_with_seu = TRUE,
  graph_based_clust = "hclust",
  QC_mm2 = TRUE,
  s1_percent_pass_score = 80,
  AS_percent_pass_score = 80,
  NM_thresh = 15,
  de_thresh = 0.01,
  top_by_read_frac = 0.85,
  bulk_to_perCB_threshold = 2000,
  allowed_alleles_per_cell = c(1, 200),
  stringent_mode = TRUE,
  correct_alleles = TRUE,
  hclust_algorithm = "complete",
  kmeans_algorithm = "Hartigan-Wong",
  n_PCs = 100,
  field_resolution = 3,
  parallelize = TRUE,
  ...
)
}
\arguments{
\item{reads_1}{is the primary scrHLAtag count file (1 of 2 files containing either the mRNA molecular info or the genomic (gene) molecular info). It includes columns for CB, UMI, and HLA alleles (https://github.com/furlan-lab/scrHLAtag).}

\item{reads_2}{is the secondary scrHLAtag count file (the alternative file vs. the one designated in '\code{reads_1}' argument). It includes columns for CB, UMI, and HLA alleles (https://github.com/furlan-lab/scrHLAtag). Default is \code{NULL}, in which case it will not be able to count alternative aligment.}

\item{allogeneic_entities}{is the number 'k' of clusters to partition the UMAP space into, e.g. the number of entities or genotypes you 'think' there might be in your captured sample.}

\item{seu}{is the Seurat object associated with the scrHLAtag count file (https://satijalab.org/seurat/index.html), and entered here if matching CBs in count file with Seurat colnames is desired.}

\item{CB_rev_com}{is a logical, called \code{TRUE} if the need to obtained the reverse complement of Cell Barcodes (CBs) is desired; default is \code{FALSE}.}

\item{hla_with_counts_above}{is the number of total reads accross CBs at or above which an HLA allele is retained in the matrix.}

\item{CBs_with_counts_above}{is the number of total reads accross HLA alleles at or above which a CB is retained in the matrix. Note: at present, the function will make sure that number of CBs is equal or more than available HLA alleles in the matrix.}

\item{match_CB_with_seu}{is a logical, called \code{TRUE} if filtering CBs in the scrHLAtag count file with matching ones in the Seurat object is desired.}

\item{graph_based_clust}{is the graph-based clustering method to be used for partitioning cells based on their HLA count patterns. The choice is between a Connectivity-based method: \code{"hclust"} or \code{"umap_hclust"}, a Centroid-based method: \code{"kmeans"}, or a Distribution based method: \code{"mclust"} (for Gaussian Mixture Model). We found \code{"hclust"} had the best ability to separate allogeneic entities so we set it as Default. In some cases, applying hierarchical clustering directly on UMAP coordinates gives good allogeneic entity separation so we provide the \code{"umap_hclust"} option.}

\item{QC_mm2}{is a logical, called \code{TRUE} if removing low quality reads based on minimap2 tags is desired.}

\item{s1_percent_pass_score}{is a percentage (\code{0} to \code{100}) cuttoff from the maximum score (best quality) of the minimap2 's1' tag, which a read needs to acheive to pass as acceptable; default at \code{80} and becomes less inclusive if value increases.}

\item{AS_percent_pass_score}{is a percentage (\code{0} to \code{100}) cuttoff from the maximum score (best quality) of the minimap2 'AS' tag, which a read needs to acheive to pass as acceptable; default at \code{80} and becomes less inclusive if value increases.}

\item{NM_thresh}{is the number of mismatches and gaps in the minimap2 alignment at or below which the quality of the read is acceptable; default is \code{15}.}

\item{de_thresh}{is the gap-compressed per-base sequence divergence in the minimap2 alignment at or below which the quality of the read is acceptable; the number is between \code{0} and \code{1}, and default is \code{0.01}.}

\item{top_by_read_frac}{is the fraction (\code{0} to \code{1}) of total reads for a particular HLA gene, which incorporates the highest ranking alleles of that gene in terms of number of reads; default at \code{0.85}.}

\item{bulk_to_perCB_threshold}{is a numeric, a threshold of number of uniquely mapped HLA alleles in the primary count file \code{read_1} above which listing the top alleles uses the Pseudo-Bulk Algorithm and below which it uses the Per Single-Cell Algorithm. Default is \code{2000}.}

\item{allowed_alleles_per_cell}{is a numeric (single or range) determining the minimum and maximum number of highest ranking allele genotypes per cell to keep if such number is beyond those limits after filtering by fraction; default is \code{c(1, 200)}, usefull in the early scrHLAtag iterations to give minimap2 lots of room to align; once you are ready to finalize the top HLA allele list, you can try \code{c(1, 2)} if you assume a cell can have a min of 1 allele (homozygous) and a max of 2 (heterozygous).}

\item{stringent_mode}{is a logical, when called \code{TRUE}, the algorithm detects when the final iteration is near (unique alleles in read file is equal or less than 200 per allogeneic entity); thus, getting top alleles becomes more stringent, with \code{allowed_alleles_per_cell} switching to \code{c(1, 2)}. This argument, however, will be ignored if the user inputs values for \code{allowed_alleles_per_cell} other than its default or if the Pseudo-Bulk algorithm is running instead of the per Single-Cell algorithm.}

\item{correct_alleles}{is a logical. Minimap2 of scrHLAtag preferentially maps reads that are in fact DPA1*02:02:02, A*03:01:01, B*13:02:01, C*02:02:02, or C*04:01:01, to DPA1*02:38Q, A*03:437Q, B*13:123Q, C*02:205Q, or C*04:09N/C*04:61N, respectively. When called \code{TRUE}, the algorithm will replace the unlikely allele(s) with their 'correct' version(s). Will work if \code{stringent_mode} is \code{TRUE} and its own conditions to work are met (as explained above).}

\item{hclust_algorithm}{applies to \code{stats::hclust()}; is the agglomeration algorithm to be used. Values include \code{"ward.D"}, \code{"ward.D2"}, \code{"single"}, \code{"complete"}, \code{"average"}, \code{"mcquitty"}, \code{"median"}, or \code{"centroid"}; for more information: \code{?stats::hclust}.}

\item{kmeans_algorithm}{applies to \code{stats::kmeans()}; is the k-means algorithm to be used. Values include \code{"Hartigan-Wong"}, \code{"Lloyd"}, \code{"Forgy"}, or \code{"MacQueen"}; for more information: \code{?stats::kmeans}.}

\item{n_PCs}{is a numeric, representing the number of top principal components to retain in downstream clustering and umap analyses; default is \code{100} or the top 80% of PCs, whichever is smaller.}

\item{field_resolution}{is a numeric, to select the HLA nomenclature level of Field resolution, where \code{1}, \code{2}, or \code{3} will take into consideration the first, the first two, or the first three field(s) of HLA designation; default is \code{3}.}

\item{parallelize}{is a logical, called \code{TRUE} if using parallel processing (multi-threading) is desired; default is \code{TRUE}.}

\item{...}{arguments passed onto \code{uwot::umap()}.}
}
\value{
a Vector of the top HLA alleles in the count files (in terms of reads per Cell Barcode).
}
\description{
A comprehensive function to extract the top HLA alleles from the scrHLAtag count files (based on the most counts per Cell Barcode)
}
\examples{
samples <- c("AML_101_BM", "AML_101_34")
mol_info <- c("molecule_info_gene.txt.gz", "molecule_info_mRNA.txt.gz")
cts <- list()
for (i in 1:length(mol_info)){
  dl<-lapply(samples, function(sample){
    d<-read.table(file.path("path/to/scrHLAtag/out/files", sample,
                            mol_info[i]), header = F, sep=" ", fill = T) 
    d$V1<-paste0(sample, "_", d$V1, "-1")
    colnames(d)<-c("name","CB", "nb", "UMI", "gene", "query_len","start", "mapq", "cigar", "NM", "AS", "s1", "de", "seq")
    d$samp <- sample
    d
  })
  ctsu<-do.call(rbind,dl)
  rm(dl)
  cts[[str_sub(strsplit(mol_info[i], "\\\\.")[[1]][1], start= -4)]] <- ctsu
  rm(ctsu)
}
top_alleles <- Top_HLA_list(reads_1 = cts[["mRNA"]], reads_2 = cts[["gene"]], seu = your_Seurat_Obj)
# 
# Note: the function is optimized to choose whether to find top HLA alleles
# using a Pseudo-Bulk algorithm (large number of uniquely mapped alleles) or 
# a Single-Cell algorithm (number of alleles is fewer than 2000).
# 
# Note: if for a particular HLA, the alleles with the most counts are in a tie 
# between 3 or more alleles in a particular Cell Barcode, we cannot know which 
# ones are the top two alleles, so that CB is not counted. This is similar if  
# there were no counts for that allele (all zeros).
}
